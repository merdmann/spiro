{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"Sys",
				"system"
			]
		]
	},
	"buffers":
	[
		{
			"file": "files.ml",
			"settings":
			{
				"buffer_size": 248,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "(*  This file is part of Spiro.\n\n    Spiro is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Spiro is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with Spiro.  If not, see <http://www.gnu.org/licenses/>.\n\n*)\n\n(** This module draws the contents of a metafile in a given refernce frame *)\n\nopen Graphics;;\nopen Drawables;;\nopen Printf;;\nopen Transformation;;\n\nexception Metafile_Not_Found ;;\nexception End_of_Metafile ;;\n\ntype form_type = Rectangle of Drawables.rectangle_type \n    | Line of Drawables.line_type				(* draw a line *)\n    | Circle of Drawables.circle_type 			(* draw a circle *)\n    | Point of Drawables.point_type				(* draw a point *)\n    | Set of Drawables.point_type    			(* set the cursor *)\n    | Move of Drawables.move_type    			(* move the cursor *) \n    | Draw of metafile_type				        (* draw a meta file *)\n	| Rotate of float                       	(* rotate by a given turn *)\n	| Scale of float                        	(* scale *)\n	| Repeat of int                         	(* repeat the next operation n times *)\n  	| Null\n	and metafile_type = { \n	 	mutable name  : string;\n   		mutable items : form_type list;		(* list of elements *)     \n	};;\n\n\n(* reference frame *)\ntype frame_type = {\n	mutable origin : point_type;\n	mutable turn   : float;\n	mutable scale  : float \n};;\n\n\n(* this maintains the intepreter state *)\ntype interpreter_state_type = \n{\n	mutable cursor  : point_type ;\n	mutable current : metafile_type;\n	mutable files   : (string * metafile_type) list;\n};;\n\nlet make_metafile mf_name = \n	if mf_name = \"\" then  { name = \"xxxyyy\" ; items = [] } else { name = mf_name; items = [] };; \n\n(* make an blank interpreter *)\nlet make_interpreter () = {\n  cursor = make_point 0 0;\n	current = make_metafile \"\"; \n	files = [ (\"\", make_metafile \"\" ) ]};;\n\nlet make_frame ?(myturn = 0.0) ?(myscale = 1.0) x y = \n				{ origin = make_point x y; turn = myturn; scale = myscale};;\n\n	\nlet frame_to_string f = sprintf \"origin=%s turn=%f scale=%f\" (to_string f.origin) f.turn f.scale ;;		\n				\n(* get the current cursor *)\nlet get_cursor interp =\n	interp.cursor\n;;\n\n(* set the cursor *)\nlet set_cursor interp value =\n	interp.cursor <- value\n;;	\n\n(* list the files stored in the interpreter *)\nlet list_metafiles interp = \n	List.iter (fun x -> \n			let name = (fst x) in\n			let file = (snd x) in\n		  	if name = \"\" then\n					printf \"%s %d\\n\" file.name (List.length file.items)\n				else \n					printf \"%s %d\\n\" name (List.length file.items) \n	  ) interp.files \n;;\n\n(* store the current metafile with a given name in the interpreter *)\nlet store interp name =\n	let exist n  = \n		try List.assoc n interp.files; true\n		with Not_found -> false in \n			\n	if (exist name) then\n		interp.files <- List.remove_assoc name interp.files ;\n				\n  interp.current.name <- name ;\n  interp.files <- List.append interp.files [ ( name, interp.current ) ];\n	interp.current <- make_metafile \"\"\n;;\n\n(* add an item to the metafile *)\nlet add interp item = \n	interp.current.items <- List.append interp.current.items [ item ] \n;;\n\n(* clear the current metafile *)\nlet clear_metafile interp = \n	interp.current <- make_metafile \"\";\n;;		\n\n(* get a metafile by name *)\nlet get_metafile interp name = \n	if name = \"\" then\n		 interp.current \n  else \n		try \n			List.assoc name interp.files \n		with Not_found ->\n			raise Metafile_Not_Found\n;;\n\n(* draw the metafile in a given frame *)\nlet rec draw interp f frame =\n		let cursor = make_point 0 0 in\n		let myframe = frame in \n		let repeat = ref 1 in\n\n	\n	  (* printf \"Draw %s %s\\n\" f.name (frame_to_string myframe); *)\n		let tr p = translation ( scale myframe.scale (rotate myframe.turn p)) myframe.origin in  \n		\n		List.iter (fun o ->\n			let c = tr cursor in  \n    	let ox = c.x  in\n    	let oy = c.y  in \n      	moveto ox oy;\n				draw_circle ox oy 5;\n				\n  			match o with\n          (Line a)      -> let p = tr a.right_point in rlineto p.x p.y\n        | (Circle a)    -> draw_circle ox oy (scale_int a.radius myframe.scale)\n        | (Rectangle a) -> let connect x y  = \n															let q = tr (translation (make_point x y) cursor) in lineto q.x q.y \n																in\n																	connect a.right_corner.x 0;\n																	connect a.right_corner.x a.right_corner.y;\n																	connect  0 a.right_corner.y;\n																	connect 0 0\n        | (Point a)     -> plot ox oy\n        | (Draw a)      -> myframe.origin <- cursor ; \n													 for i=1 to !repeat do draw interp a myframe done\n				| (Scale a)     -> myframe.scale <- a\n				| (Rotate a)    -> myframe.turn <- myframe.turn +. a \n        | (Set a)       -> cursor.x <- a.y ; cursor.y <- a.y\n				| (Move a)      -> cursor.x <- cursor.x + a.dx; cursor.y <- cursor.y + a.dy \n				| (Repeat a)    -> (* in case of a repeat we create a new reference fram *)\n													repeat := a \n        | _             -> print_endline \"Unknown operation\" \n     	)\n  	 	f.items ;\n			\n			interp.cursor <- cursor\n;;\n\n(* draw the commands which are stored in the interpreter *)\nlet display interp frame name  = \n	if name = \"\" then\n		draw interp interp.current frame\n	else \n		let metafile = List.assoc( name ) interp.files in\n			draw interp metafile frame\n;;\n\n(* dump a metafile on the standard output *)\nlet display_source ?(chan=stdout) f  =   \n	let cnt = ref 0 in\n		List.iter (fun o ->  \n				let operation = match o with\n          		(Line a)      -> sprintf \"line %s\" (to_string a.right_point)\n        		| (Circle a)    -> sprintf \"circle %d\" a.radius \n        		| (Rectangle a) -> sprintf \"rect %s\" (to_string a.right_corner)\n        		| (Point a)     -> sprintf \"plot %s\" (to_string a)\n        		| (Set a)       -> sprintf \"set %s\"  (to_string a)\n						| (Move a)      -> sprintf \"move %d %d\" a.dx a.dy \n        		| (Draw a)      -> sprintf \"draw %s\" a.name\n						| (Repeat a)    -> sprintf \"repeat %d\" a\n						| (Rotate a)    -> sprintf \"turn %f\" (deg_from_rad a)\n						| (Scale a)     -> sprintf \"scale %f\" a \n        		| _             -> sprintf \"unknown operation\" in				\n			  				if chan = stdout then begin\n									cnt := !cnt + 1;\n									printf \"%2.2d %s\\n\" !cnt operation\n									end \n			  				else \n			 					fprintf chan \"%s\\n\" operation\n			) \n			f.items \n;;\n",
			"file": "script.ml",
			"file_size": 6616,
			"file_write_time": 129820948960000000,
			"settings":
			{
				"buffer_size": 6625,
				"line_ending": "Unix"
			}
		},
		{
			"file": "drawables.mli",
			"settings":
			{
				"buffer_size": 1277,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Makefile",
			"settings":
			{
				"buffer_size": 325,
				"line_ending": "Windows"
			}
		},
		{
			"file": "drawables.ml",
			"settings":
			{
				"buffer_size": 1499,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "(* This file is part of Spiro.\n\n    Spiro is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Spiro is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with Spiro.  If not, see <http://www.gnu.org/licenses/>.\n\n*)\n\n(** This file contains the main loop of the application. *)\nopen Script;;\nopen Drawables;;\nopen Graphics;;\nopen Genlex;;\nopen Helper;;\nopen Files;;\nopen Printf;;\nopen String;;\nopen Filename;;\n(* open Unix;; *)\nopen Sys;;\nopen Printexc;;\nopen Transformation;;\n\nexception Session_End;;\nexception Unknown_Command;;\nexception Syntax_Error ;;\nexception File_Not_Existing ;;\n\n(** the session state is stored here *)\ntype session_state_type = \n{ \n	mutable repeat   : int;\n	mutable interp   : interpreter_state_type;\n   	mutable active   : bool ; 		    (* command loop is still active *)\n   	mutable screen_size_x : int;\n   	mutable screen_size_y : int;          \n	mutable editor   : string         \n};;\n  \n(* setup the initial state of the application *)\nlet state = { \n	active = true; \n	repeat = 1;\n	interp=make_interpreter();\n    screen_size_x = 900;\n    screen_size_y = 900;\n	editor=\"gedit\" \n};;\n\nlet reset_frame f = \n		f.origin <- make_point 0 0;\n		f.turn <- 0.0;\n		f.scale <- 1.0 \n;;\n\nlet root_frame = { origin = make_point 0 0; turn=0.0; scale=1.0 } ;;\n\n\n(** get next token; if there is nothing found we return \"\" keyword in order \n *  to simplyfy the parsing of the command line arguments. \n *)\nlet next_token t =\n  try\n    Stream.next t\n  with Stream.Failure -> \n    (Kwd \"\")\n;;\n\n(* get a point from the input stream *)\nlet get_point t =\n  let pnt = ( next_token t, next_token t, next_token t) in \n    match pnt with \n        Int x, Kwd \"/\", Int y -> make_point x y \n			| Kwd \"\", Kwd \"\", Kwd \"\" -> make_point 0 0\n      | _ -> raise Syntax_Error \n;;\n\n(* readin a given distance *)\nlet get_distance t = \n  let dist = next_token t in \n    match dist with \n      Int x ->  x\n      | _ -> raise Syntax_Error   \n;;\n\nlet get_name t =\n  let name = next_token t in\n  match name with \n    Ident x -> x;\n    | _ -> raise Syntax_Error \n;;\n\n        \n(** set the cursor to the specified point *)\nlet do_set t = \n  add state.interp (Set (get_point t));  \n;; \n\n(** move the cursor *)\nlet do_move t =\n	match next_token t, next_token t with\n		Int a, Int b ->\n				 add state.interp (Move { dx=a; dy=b})\n		| _ -> raise Syntax_Error\n;;\n\n(** set the turn value *)\nlet do_turn t = \n		match next_token t with\n		  Int a -> add state.interp (Rotate (rad_from_deg (float_of_int a)))\n		| Float a -> add state.interp (Rotate (rad_from_deg a))\n		| _ -> raise Syntax_Error\n;;\n\nlet do_scale t = \n		match next_token t with\n		  Int a -> add state.interp (Scale (float_of_int a))\n		| Float a -> add state.interp (Scale a)\n		| _ -> raise Syntax_Error\n;;\n\n(** create a rectangle *)\nlet do_rectangle t = \n  let lx = get_distance t in\n  	let ly = get_distance t in \n  add state.interp (Rectangle (make_rectangle lx ly));  \n;;\n\n(** create a circle *)\nlet do_circle t =\n  let r = get_distance t in\n 	add state.interp (Circle (make_circle r));;      \n\n(** draw a line *)\nlet do_line t = \n  let p = get_point t in\n  	add state.interp (Line (make_line p.x p.y));;      \n\n(** store the current a meta file with a given name and start a new one *)\nlet do_store t = \n  let name = get_name t in\n  	store state.interp name \n;;\n\n(** clear the screen and the current metafile *)\nlet do_clear t =\n	clear_graph () ;\n	root_frame.turn <- 0.0;\n	root_frame.scale <- 1.0;\n	root_frame.origin <- make_point 0 0;\n	set_cursor state.interp (make_point 0 0) ;\n	clear_metafile state.interp\n;;\n\n(** draw either the current matafile or a names metafile *)\nlet do_draw t =\n  match next_token t, next_token t, next_token t with\n      Int x, Kwd \"/\", Int y -> display state.interp root_frame \"\"\n    | Ident name, _ , _ -> add state.interp (Draw (get_metafile state.interp name))\n    | _ -> display state.interp root_frame \"\"\n;;  \n\n\n(** set the screen dimensions *)\nlet do_resize x y = \n  state.screen_size_x <- x;\n  state.screen_size_y <- y;\n  resize_window state.screen_size_x state.screen_size_y \n;;\n  \n(** resize the visible canvas *)\nlet do_screen t =\n  match Stream.next t, Stream.next t with\n    Int x, Int y -> do_resize x y\n    | Int x, _ -> do_resize x state.screen_size_y\n    | _ -> raise Syntax_Error\n;;\n\n(** list the avaiable metafiles *)\nlet do_list t =\n  match next_token t with\n    | Ident a -> display_source (get_metafile state.interp a) \n    | _ -> display_source (get_metafile state.interp \"\") \n;; \n\nlet do_info t = \n	printf \" Scale=%f, Turn=%f, origin=%s \\n\" \n							root_frame.scale root_frame.turn (Drawables.to_string root_frame.origin)\n;;\n\n(** Save the given metafile f into file with the name f.mf *) \nlet do_save t =\n	match next_token t with\n		| Ident name -> let f = get_metafile state.interp name in\n											let chn = open_out (name ^ \".mf\") in\n												display_source ~chan:chn f;\n												close_out chn;\n		| _ -> raise Syntax_Error\n;;\n\n\n(** the list of commands *)\nlet lexer = make_lexer [ \n			(* grafical commands *)\n			\"rect\"; \"circle\"; \"line\"; \n			\"quit\"; \"set\" ; \"move\"; \"turn\"; \"scale\" ; \n\n			(* online dialog *)\n			\"draw\"; \"!\"; \"?\" ;\n			\"save\"; \"load\"; \"edit\";\n			(* screen related command  *)\n			\"screen\"; \"clear\" ; \n			(* metafile commands *)\n			\"store\"; \"dir\"; \"list\";\n			\n			(* argument elements *)\n			\"/\"; \",\"; 			\n			 ]\n;;\n\n(** interpret a command and execute it *)\nlet rec execute_command token =\n    match (Stream.next token) with\n			(* cursor movements *)\n        	  Kwd \"move\"   -> do_move token\n			| Kwd \"set\"    -> do_set token				\n			| Kwd \"turn\"   -> do_turn token\n			| Kwd \"scale\"  -> do_scale token \n			(* grafical object *)\n      		| Kwd \"rect\"   -> do_rectangle token\n      		| Kwd \"circle\" -> do_circle token\n      		| Kwd \"line\"   -> do_line token        \n      		| Kwd \"draw\"   -> do_draw token\n			| Int value    -> add state.interp (Repeat value); execute_command token\n			(* management functions *)												\n			| Kwd \"clear\"  -> do_clear token\n      		| Kwd \"quit\"   -> raise Session_End\n      		| Kwd \"store\"  -> do_store token      \n      		| Kwd \"screen\" -> do_screen token		 \n			| Kwd \"dir\"    -> list_metafiles state.interp\n			| Kwd \"list\"   -> do_list token\n			| Kwd \"!\"      -> do_batch (get_name token)\n			| Kwd \"save\"   -> do_save token\n			| Kwd \"load\"   -> do_load token\n			| Kwd \"edit\"   -> do_edit token\n			| Kwd \"?\"      -> do_info token\n			(* if no keyword is matching, use the identifer as metafile name *)\n      		| Ident name   ->	( try add state.interp (Draw (get_metafile state.interp name))\n					 								with Metafile_Not_Found -> raise Unknown_Command )\n			(* if nothing matches *)		\n		  	| _ ->  raise Unknown_Command\nand do_batch name = \n		let chan = open_in name in\n		try 	\n			while true do		\n   			let cmd = input_line chan in\n					if (length cmd) > 0 then if (get cmd 0) != '#' then begin				\n						let token = lexer (Stream.of_string cmd) in\n							execute_command token;\n					end \n			done\n		with End_of_file -> close_in chan		\n		\nand do_edit t =\n		match next_token t with\n			Ident name -> \n				let f = get_metafile state.interp name in\n				let tmp = temp_file name \".mf\" in\n				let chn = open_out tmp in\n					display_source ~chan:chn f;\n					close_out chn;\n					let result = command (\"vi \" ^ tmp) in begin\n						if( result != 0 ) then\n						    printf \"Error ***\\n\";\n					end \n			| _ -> raise Syntax_Error\n\nand do_load t =\n	let name = get_name t in \n		do_clear t;\n		do_batch (name ^ \".mf\");\n		store state.interp name \n;;\n\n(** toplevel starts here *)\nopen_graph \"\";;\n\nlet cfg : config_type = make_config_type ;;\n\nload_config \"powa.cfg\" cfg ;;\n\nstate.screen_size_x = config_int \"screen_size_x\" cfg;;\nstate.screen_size_y = config_int \"screen_size_y\" cfg;;\n\nresize_window state.screen_size_x state.screen_size_y ;;\nset_window_title \"Spiro\";;\n\nwhile state.active do\n	try \n   		begin   \n				reset_frame root_frame; \n				display state.interp root_frame \"\";\n     		print_point(get_cursor state.interp);\n    		print_string \" ? \";  \n    		let cmd = read_line () in\n				   if (length cmd)>0 then\n  			   	  let token = lexer (Stream.of_string cmd) in\n    						 execute_command token;         \n  		end \n	with x ->\n		match x with\n     	Session_End -> \n         	print_endline \"done.\";\n       		state.active <- false;\n       | File_Not_Existing -> print_endline \"Error: metafile not exiting ****\"\n       | Unknown_Command -> print_endline \"Error: unkown command ****\"\n       | Syntax_Error -> print_endline \"Error: Syntactical Error ****\" \n			 | Metafile_Not_Found -> printf \"Metafile not found ****\\n\"      \n       | _ as exn -> printf \"Exception %s *******\\n\" (Printexc.to_string exn )\ndone ;;\n\n",
			"file": "main.ml",
			"file_size": 9063,
			"file_write_time": 130645147483351306,
			"settings":
			{
				"buffer_size": 9083,
				"line_ending": "Unix"
			}
		},
		{
			"file": "helper.ml",
			"settings":
			{
				"buffer_size": 1715,
				"line_ending": "Unix"
			}
		},
		{
			"file": "main.mli",
			"settings":
			{
				"buffer_size": 1427,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "Packages/Makefile/Make.sublime-build",
	"command_palette":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/Users/MIchael/Documents/Sources/spiro",
		"/C/Users/MIchael/Documents/Sources/spiro/src"
	],
	"file_history":
	[
		"/C/Users/MIchael/Documents/Sources/spiro/src/script.mli",
		"/C/Users/MIchael/Documents/Sources/spiro/src/main.mli",
		"/C/Users/MIchael/Documents/Sources/spiro/src/drawables.ml",
		"/C/Users/MIchael/Documents/Sources/spiro/src/spiro.sublime-project",
		"/C/Users/MIchael/Documents/Sources/spiro/src/files.mli",
		"/C/Users/MIchael/Documents/Sources/spiro/powa.cfg",
		"/D/Michael/OneDrive/www/WebMatrix/homepage/theme/rt14gs/css/fonts.css",
		"/D/Michael/OneDrive/www/WebMatrix/homepage/theme/rt14gs/css/structure.css",
		"/D/Michael/OneDrive/www/WebMatrix/homepage/theme/rt14gs/css/styles.css",
		"/D/Michael/OneDrive/www/WebMatrix/homepage/theme/rt14gs/functions.php",
		"/D/Michael/OneDrive/www/WebMatrix/homepage/theme/rt14gs/template.php",
		"/Y/Software/Archive/old_cds/fd_pcwdsk1/src/clipline.c",
		"/Y/Software/Archive/old_cds/fd_case/case/idl/dmlpps.c",
		"/D/Michael/OneDrive/www/WebMatrix/homepage/theme/rt14gs/js/dd_belatedpng.js",
		"/C/Users/MIchael/AppData/Roaming/Sublime Text 3/Packages/Default/Default (Windows).sublime-keymap",
		"/D/Michael/OneDrive/www/WebMatrix/homepage/data/pages/muon-detector.xml",
		"/D/Michael/OneDrive/www/WebMatrix/homepage/data/pages/a-google-script-example.xml",
		"/C/Users/MIchael/Documents/Sources/tam/tamtest.gpr",
		"/C/Users/MIchael/Documents/Sources/tam/trunk/Makefile",
		"/C/Users/MIchael/Documents/Sources/tam/.gitignore",
		"/C/Users/MIchael/Documents/Sources/tam/tam.gpr",
		"/C/Users/MIchael/Documents/Sources/tam/README.md",
		"/C/Users/MIchael/Documents/Sources/tam/.git/config",
		"/C/Users/MIchael/Documents/adventure/trunk/Location.cpp",
		"/C/Users/MIchael/Documents/Sources/Adventure/trunk/Door.cpp"
	],
	"find":
	{
		"height": 26.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"  ",
			"drawables"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 5,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "files.ml",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 248,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/OCaml/OCaml.tmLanguage"
						},
						"translation.x": -0.0,
						"translation.y": 54.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "script.ml",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6625,
						"regions":
						{
						},
						"selection":
						[
							[
								763,
								763
							]
						],
						"settings":
						{
							"syntax": "Packages/OCaml/OCaml.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "drawables.mli",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1277,
						"regions":
						{
						},
						"selection":
						[
							[
								342,
								342
							]
						],
						"settings":
						{
							"syntax": "Packages/OCaml/OCaml.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "Makefile",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 325,
						"regions":
						{
							"mark":
							{
								"flags": 144,
								"icon": "dot",
								"regions":
								[
									[
										288,
										288
									]
								],
								"scope": "mark"
							}
						},
						"selection":
						[
							[
								290,
								290
							]
						],
						"settings":
						{
							"auto_name": "",
							"syntax": "Packages/Makefile/Makefile.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "drawables.ml",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1499,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/OCaml/OCaml.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "main.ml",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9083,
						"regions":
						{
							"mark":
							{
								"flags": 144,
								"icon": "dot",
								"regions":
								[
									[
										7744,
										7744
									]
								],
								"scope": "mark"
							}
						},
						"selection":
						[
							[
								5746,
								5746
							]
						],
						"settings":
						{
							"syntax": "Packages/OCaml/OCaml.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 3834.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "helper.ml",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1715,
						"regions":
						{
						},
						"selection":
						[
							[
								1439,
								1439
							]
						],
						"settings":
						{
							"syntax": "Packages/OCaml/OCaml.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 270.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "main.mli",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1427,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/OCaml/OCaml.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 26.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"project": "spiro.sublime-project",
	"replace":
	{
		"height": 48.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 232.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
